#!/bin/bash

CURRENT_DATE=$(date +%F)

# --- 配置路径 ---
RES_DIR="res"
BIB_SRC="$RES_DIR/works.bib"
BIB_OUT="$RES_DIR/works.yml"
LIB_DIR="lib"
OUT_DIR="output"
SITEMAP="$OUT_DIR/sitemap.xml"
ASSETS_DIR="$OUT_DIR/assets"
RELOAD_SIGNAL="$OUT_DIR/.reload"

mkdir -p "$OUT_DIR"

# --- 注入函数
TO_INJECT=$(cat << EOF

		<link rel="canonical" href="https://rzheng.xyz/" />
		<meta name="color-scheme" content="light dark">
		<link rel="icon" type="image/svg+xml" href="/assets/favicon.svg">
		<meta name="theme-color" content="#ffffff" media="(prefers-color-scheme: light)">
		<meta name="theme-color" content="#1a1a1a" media="(prefers-color-scheme: dark)">
		<meta name="apple-mobile-web-app-title" content="R. Zheng">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
		<link rel="apple-touch-icon" href="/assets/icon.png">

		<link rel="manifest" href="/manifest.json">
		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="mobile-web-app-capable" content="yes">
EOF
)

inject() {
    local target=$1
    # 在 </head> 结束前插入
    perl -i -pe "s|<\/head>|$TO_INJECT\n\t<\/head>|g" "$target"
}

# --- 1. 参考文献转换 ---
update_bib() {
    if [ -f "$BIB_SRC" ]; then
        if [ ! -f "$BIB_OUT" ] || [ "$BIB_SRC" -nt "$BIB_OUT" ]; then
            echo "[BIB] 更新文献库..."
            hayagriva "$BIB_SRC" > "$BIB_OUT"
            return 0
        fi
    fi
    return 1
}

# --- 2. 编译函数 ---

# 专供 CV 编译 (PDF + 选择)
compile_cv() {
    echo "[TYPST] 独立编译 CV -> PDF"
    typst compile "cv.typ" "$OUT_DIR/cv.pdf"
    typst compile "cv.typ" "$OUT_DIR/cv-dark.pdf" --input theme=dark
    
    cat > "$OUT_DIR/cv.html" <<EOF
<!DOCTYPE html>
<html><head>
<script>
    const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
    const target = isDark ? "/cv-dark.pdf" : "/cv.pdf";
    window.location.replace(target);
</script>
</head><body></body></html>
EOF
}

# 专供 Main 编译 (HTML)
compile_main() {
	local mode=$1
    echo "[TYPST] 编译主页 -> index.html"
    typst compile "main.typ" "$OUT_DIR/index.html" --input target=html --features html
    # 注入 Favicon
    inject "$OUT_DIR/index.html"
    [ "$mode" == "watch" ] && inject_reload_js "$OUT_DIR/index.html"
}

# 通用 HTML 编译
compile_generic() {
    local f=$1
    local mode=$2
    local out="${f%.typ}.html"
    echo "[TYPST] 编译 HTML: $f"
    typst compile "$f" "$OUT_DIR/$out" --input target=html --features html
    
    # 注入
    inject_favicon "$OUT_DIR/$out"
    inject_theme_color "$OUT_DIR/$out"   
    [ "$mode" == "watch" ] && inject_reload_js "$OUT_DIR/$out"
}

inject_reload_js() {
    local target=$1
    # JS 内部使用单引号，避免与 perl/shell 冲突
    local js="<script>let lastV=''; function check(){ fetch('/.reload?t=' + Date.now(),{ cache: 'no-cache'}) .then(r=>r.text()) .then(nv=>{ if (lastV && nv !==lastV){ window.location.reload(); return;} lastV=nv; setTimeout(check, 1000);}) .catch(()=>setTimeout(check, 2000));} check();</script>"
    perl -i -pe "s|</body>|$js</body>|g" "$target"
}

trigger_reload() {
    date +%s > "$RELOAD_SIGNAL"
}

get_project_state() {
    # 监控当前目录的 .typ 文件
    # 监控引用的目录：LIB_DIR, RES_DIR, ASSETS_DIR
    # 使用 md5/cksum 汇总所有文件的修改时间、大小和路径
    {
        ls -lR *.typ "$LIB_DIR" "$RES_DIR" "$ASSETS_DIR" 2>/dev/null
    } | cksum
}

# --- Sitemap ---
get_lastmod() {
    local target_file="$1"
    # 1. 由 Shell 负责检查文件是否存在
    if [ ! -f "$target_file" ]; then
        echo "Error: File [$target_file] not found." >&2
        return 1
    fi
    # 2. 只有文件存在时，才调用 Perl 获取日期
    # perl 的逻辑被简化到极致：只负责 stat 和格式化
    perl -MPOSIX -e 'print strftime "%Y-%m-%d", localtime((stat $ARGV[0])[9])' "$target_file"
}

generate_sitemap() {
	local date_index=$(get_lastmod "$OUT_DIR/index.html") || exit 1
    # 直接在 output 根目录生成/更新
    cat > $SITEMAP <<EOF
<?xml version="1.0" encoding="UTF-8"?>
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
  <url>
    <loc>https://rzheng.com/</loc>
    <lastmod>${date_index}</lastmod>
    <priority>1.0</priority>
  </url>

</urlset>
EOF
    echo "[INFO] Sitemap generated at ./output/sitemap.xml"
}

# --- 执行逻辑 ---
case "$1" in
    update)
        update_bib
        [ -f "main.typ" ] && compile_main "update"
        [ -f "cv.typ" ] && compile_cv "update"
        for f in *.typ; do
            if [[ "$f" != "main.typ" && "$f" != "cv.typ" ]]; then
                compile_generic "$f" "update"
            fi
        done
		generate_sitemap
        echo "[DONE] 干净的构建已完成"
        ;;
    
    watch)
        echo "[SERVER] http://localhost:3000 | CV: /cv.html"
		lsof -ti:3000 | xargs kill -9 2>/dev/null || true
		python3 -m http.server 3000 --directory $OUT_DIR > /dev/null 2>&1 &
		# python3 -c "import http.server, socketserver, os; os.chdir('$OUT_DIR'); class T(socketserver.ThreadingMixIn, socketserver.TCPServer): allow_reuse_address = True; H = type('H', (http.server.SimpleHTTPRequestHandler,), {'end_headers': lambda s: [s.send_header('Cache-Control', 'no-store'), super(http.server.SimpleHTTPRequestHandler, s).end_headers()], 'log_message': lambda *a: None}); T(('', 3000), H).serve_forever()" > /dev/null 2>&1 &
        SERVER_PID=$!
        trap "kill $SERVER_PID; rm -f $RELOAD_SIGNAL; exit" SIGINT SIGTERM

        # 初始编译
        update_bib
        [ -f "main.typ" ] && compile_main "watch"
        [ -f "cv.typ" ] && compile_cv
        for f in *.typ; do
            if [[ "$f" != "main.typ" && "$f" != "cv.typ" ]]; then
                compile_generic "$f" "watch"
            fi
        done
        trigger_reload
        
        last_state=$(get_project_state)
        while true; do
            sleep 0.8
            current_state=$(get_project_state)
            
            if [ "$current_state" != "$last_state" ]; then
                echo "[WATCH] 检测到变更，正在同步..."
                # 1. 只有 LIB 或 ASSETS 变了才全量处理
				if [ -n "$(find "$LIB_DIR" "$ASSETS_DIR" -newer "$RELOAD_SIGNAL" 2>/dev/null)" ]; then
					echo "[WATCH] 核心资源变更，全量更新..."
					[ -f "main.typ" ] && compile_main "watch"
				else
					# 2. 否则，哪行坏了修哪行 (按需编译)
					update_bib
					[ "cv.typ" -nt "$OUT_DIR/cv.pdf" ] && compile_cv
					[ "main.typ" -nt "$OUT_DIR/index.html" ] && compile_main "watch"
				fi

                # 4. 触发重载并记录新状态
                trigger_reload
                last_state="$current_state"
                
                echo "[DONE] 所有页面已同步更新"
            fi
        done
        ;;
    *)
        echo "Usage: $0 {update|watch}"
        exit 1
        ;;
esac